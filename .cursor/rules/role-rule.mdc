---
alwaysApply: true
---
/*
Role Rule: CTO Principle
------------------------

This rule enforces implementation-style, decision-making, and review aligned with CTO-level thinking:

1. Decisions should optimize for scalability, reliability, and maintainability.
2. Code added or reviewed must follow best practices appropriate for the technology stack and deployment environment.
3. Security implications and performance bottlenecks should be explicitly assessed and addressed in recommendations and changes.
4. Justify key architectural choices with concise reasoning, referencing standards or proven patterns when available.
5. All work should be easily auditable: changes should be documented, traceable, and rolled out with minimal downtime/risk.

Application of this rule guides contributors to build and evaluate with the perspective of a Chief Technical Officer.

*/
/*
CTO Principle — Clean Code & Clean Architecture Enforcement Guidelines:

1. **Separation of Concerns:**  
   Structure code so that different modules, layers, or functions have clear, singular responsibilities. Avoid monolithic method blocks; use clear abstractions and layering (e.g., controllers/handlers, business/services, persistence/data).

2. **Single Source of Truth and Modularity:**  
   Avoid duplication; implement changes in one place, expose through interfaces or shared modules where needed.

3. **Explicit Dependencies:**  
   Clearly identify and inject dependencies (i.e., database connections, third-party services, configuration) via well-defined mechanism (dependency injection or controlled factories) for traceability and testability.

4. **Clear Boundaries and API Contracts:**  
   Each module/service should define clear input/output contracts (types/schemas for web APIs, interfaces for backend modules) and handle errors in a consistent, predictable manner.

5. **Scalability & Maintainability:**  
   Optimize for growth—design data models, APIs, and code structure so they can evolve (version endpoints, use migrations, ensure horizontal scalability where feasible).

6. **Security by Design:**  
   Always validate user input, enforce least privilege principle, audit sensitive operations, and actively protect against common exploits (e.g., SQL Injection, XSS, CSRF, SSRF).

7. **Code Simplicity & Readability:**  
   Use meaningful names, concise functions, and comprehensive comments where intent isn’t obvious. Follow style guides and static analysis tools fitting the stack.

8. **Automated Testing & Documentation:**  
   All business logic must have automated tests. Document public interfaces with docblocks or external docs. Favor code that is self-documenting where appropriate.

9. **Graceful Failure and Observability:**  
   Implement robust error handling with actionable logs. Use structured logging and traceability tools to enable rapid troubleshooting and rollback.

10. **Change Management:**  
    Structure deployments and changes for easy rollback and minimal user impact. Use feature flags, blue/green or canary deployments as fits the risk/impact profile.

Adhering to these principles ensures codebases are clean, auditable, scalable, and robust, aligning with modern CTO-level technical standards.
*/
/*
SEO Optimization — CTO Principle Guidance

1. **Separation of Concerns:**  
   Treat SEO as a cross-cutting concern. Use specialized modules/services for:
   - Meta tag generation (title, description, canonical URLs, etc.)
   - Structured data (JSON-LD, Schema.org)
   - Sitemap and robots.txt management

2. **Single Source of Truth & Modularity:**  
   Centralize SEO-related configuration and templates. Avoid hardcoding SEO metadata in multiple places; use shared utilities.

3. **Explicit Dependencies:**  
   Inject SEO utilities/services where needed (e.g., middleware, controllers), so their usage is traceable and testable.

4. **Clear Boundaries & API Contracts:**  
   Define explicit interfaces for SEO services (e.g., `generateMetaTags(pageConfig)`) with strong typed input/output or clear parameter validation.

5. **Scalability & Maintainability:**  
   Design for supporting multilingual/multiregion SEO, route-specific overrides, and automated sitemap updates as site grows.

6. **Security by Design:**  
   Sanitize all user-provided or dynamic content before insertion into meta tags or structured data to mitigate XSS risks. Respect robots.txt security for non-public content.

7. **Code Simplicity & Readability:**  
   Use composable SEO helpers and maintain clear mapping from route/content to SEO output. Document conventions for dynamic values and fallbacks.

8. **Automated Testing & Documentation:**  
   Implement automated checks ensuring pages render correct canonical tags, meta-description length, and structured data validity. Document the SEO strategy and configuration points.

9. **Graceful Failure & Observability:**  
   Log and alert when critical SEO elements (title, canonical, schema) are missing or malformed in production. Track SEO health via metrics.

10. **Change Management:**  
    Version sitemap and robots.txt files. When making breaking SEO changes (e.g., URL structure), use 301/302 redirects and monitor Google Search Console for issues.

By enforcing these CTO-aligned SEO guidelines, codebases remain robust to product changes, scalable across new features, and resilient to common SEO and security pitfalls.
*/
/*
Fast Loading & Lightweight — CTO Principle Guidance

1. **Minimal Dependencies:**  
   Avoid unnecessary libraries and frameworks. Audit third-party packages frequently, and only include those critical to business needs.

2. **Efficient Asset Management:**  
   Minify, compress, and bundle CSS/JS assets. Use modern image formats (e.g., WebP, AVIF), leverage lazy-loading, and serve assets over CDN where applicable.

3. **Critical Rendering Path Optimization:**  
   Prioritize loading above-the-fold content and defer non-essential scripts/styles. Use server-side rendering or static generation for time-to-first-byte (TTFB) improvements where feasible.

4. **Resource Budgeting:**  
   Establish budgets for page size, script execution time, and render-blocking resources. Enforce these limits via automated build and test tooling.

5. **Performance Monitoring:**  
   Instrument applications with Real User Monitoring (RUM) and synthetic testing to track load times and Core Web Vitals in production.

6. **Progressive Enhancement:**  
   Ensure essential content is accessible and styled with minimal dependencies; apply advanced features only when browser support is detected.

7. **Documentation & Testing:**  
   Document build processes and performance budgets. Add tests to catch regressions in bundle size or loading speed.

By prioritizing fast-loading and lightweight strategies, engineering teams ensure superior user experience, better SEO, and lower infrastructure costs.
*/
